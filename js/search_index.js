var search_data = {"index":{"searchIndex":["array","csv","fieldsconverter","inputrecordseparator","invalidencodingerror","malformedcsverror","parser","inputsscanner","invalidencoding","scanner","unexpectederror","row","tsv","table","writer","object","string","<<()","<<()","<<()","<<()","==()","==()","csv()","[]()","[]()","[]=()","[]=()","add_converter()","add_row()","binmode?()","by_col()","by_col!()","by_col_or_row()","by_col_or_row!()","by_row()","by_row!()","check()","col_sep()","column_separator()","convert()","convert()","converters()","deconstruct()","deconstruct_keys()","delete()","delete()","delete_if()","delete_if()","dig()","dig()","each()","each()","each()","each()","each_line()","each_line()","each_pair()","empty?()","eof()","eof?()","eof?()","eos?()","fetch()","field()","field?()","field_row?()","field_size_limit()","field_size_limit()","fields()","filter()","flock()","force_quotes?()","foreach()","generate()","generate_line()","generate_lines()","gets()","has_key?()","header?()","header_convert()","header_converters()","header_row?()","header_row?()","header_row?()","headers()","headers()","headers()","headers()","include?()","index()","initialize_copy()","inspect()","inspect()","inspect()","instance()","ioctl()","keep_back()","keep_back()","keep_drop()","keep_drop()","keep_end()","keep_end()","keep_start()","keep_start()","key?()","liberal_parsing?()","liberal_parsing?()","line()","line()","lineno()","lineno()","max_field_size()","max_field_size()","member?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","open()","parse()","parse()","parse_csv()","parse_line()","path()","push()","push()","puts()","quote_char()","quote_character()","read()","read()","readline()","readlines()","readlines()","rest()","return_headers?()","return_headers?()","rewind()","rewind()","row_sep()","row_separator()","scan()","scan_all()","shift()","skip_blanks?()","skip_blanks?()","skip_lines()","skip_lines()","stat()","table()","to_a()","to_csv()","to_csv()","to_csv()","to_h()","to_hash()","to_i()","to_io()","to_s()","to_s()","unconverted_fields?()","unconverted_fields?()","use_headers?()","value()","values_at()","values_at()","write_headers?()","license","news","readme","filtering","generating","parsing","recipes"],"longSearchIndex":["array","csv","csv::fieldsconverter","csv::inputrecordseparator","csv::invalidencodingerror","csv::malformedcsverror","csv::parser","csv::parser::inputsscanner","csv::parser::invalidencoding","csv::parser::scanner","csv::parser::unexpectederror","csv::row","csv::tsv","csv::table","csv::writer","object","string","csv#<<()","csv::row#<<()","csv::table#<<()","csv::writer#<<()","csv::row#==()","csv::table#==()","object#csv()","csv::row#[]()","csv::table#[]()","csv::row#[]=()","csv::table#[]=()","csv::fieldsconverter#add_converter()","csv#add_row()","csv#binmode?()","csv::table#by_col()","csv::table#by_col!()","csv::table#by_col_or_row()","csv::table#by_col_or_row!()","csv::table#by_row()","csv::table#by_row!()","csv::parser::inputsscanner#check()","csv#col_sep()","csv::parser#column_separator()","csv#convert()","csv::fieldsconverter#convert()","csv#converters()","csv::row#deconstruct()","csv::row#deconstruct_keys()","csv::row#delete()","csv::table#delete()","csv::row#delete_if()","csv::table#delete_if()","csv::row#dig()","csv::table#dig()","csv#each()","csv::fieldsconverter#each()","csv::row#each()","csv::table#each()","csv::parser::inputsscanner#each_line()","csv::parser::scanner#each_line()","csv::row#each_pair()","csv::fieldsconverter#empty?()","csv#eof()","csv#eof?()","csv::parser::eof?()","csv::parser::inputsscanner#eos?()","csv::row#fetch()","csv::row#field()","csv::row#field?()","csv::row#field_row?()","csv#field_size_limit()","csv::parser#field_size_limit()","csv::row#fields()","csv::filter()","csv#flock()","csv#force_quotes?()","csv::foreach()","csv::generate()","csv::generate_line()","csv::generate_lines()","csv#gets()","csv::row#has_key?()","csv::row#header?()","csv#header_convert()","csv#header_converters()","csv#header_row?()","csv::parser#header_row?()","csv::row#header_row?()","csv#headers()","csv::parser#headers()","csv::row#headers()","csv::table#headers()","csv::row#include?()","csv::row#index()","csv::row#initialize_copy()","csv#inspect()","csv::row#inspect()","csv::table#inspect()","csv::instance()","csv#ioctl()","csv::parser::inputsscanner#keep_back()","csv::parser::scanner#keep_back()","csv::parser::inputsscanner#keep_drop()","csv::parser::scanner#keep_drop()","csv::parser::inputsscanner#keep_end()","csv::parser::scanner#keep_end()","csv::parser::inputsscanner#keep_start()","csv::parser::scanner#keep_start()","csv::row#key?()","csv#liberal_parsing?()","csv::parser#liberal_parsing?()","csv#line()","csv::parser#line()","csv#lineno()","csv::parser#lineno()","csv#max_field_size()","csv::parser#max_field_size()","csv::row#member?()","csv::new()","csv::fieldsconverter::new()","csv::invalidencodingerror::new()","csv::malformedcsverror::new()","csv::parser::new()","csv::parser::inputsscanner::new()","csv::parser::scanner::new()","csv::row::new()","csv::tsv::new()","csv::table::new()","csv::writer::new()","csv::open()","csv::parse()","csv::parser#parse()","string#parse_csv()","csv::parse_line()","csv#path()","csv::row#push()","csv::table#push()","csv#puts()","csv#quote_char()","csv::parser#quote_character()","csv::read()","csv#read()","csv#readline()","csv::readlines()","csv#readlines()","csv::parser::inputsscanner#rest()","csv#return_headers?()","csv::parser#return_headers?()","csv#rewind()","csv::writer#rewind()","csv#row_sep()","csv::parser#row_separator()","csv::parser::inputsscanner#scan()","csv::parser::inputsscanner#scan_all()","csv#shift()","csv#skip_blanks?()","csv::parser#skip_blanks?()","csv#skip_lines()","csv::parser#skip_lines()","csv#stat()","csv::table()","csv::table#to_a()","array#to_csv()","csv::row#to_csv()","csv::table#to_csv()","csv::row#to_h()","csv::row#to_hash()","csv#to_i()","csv#to_io()","csv::row#to_s()","csv::table#to_s()","csv#unconverted_fields?()","csv::parser#unconverted_fields?()","csv::parser#use_headers?()","csv::inputrecordseparator::value()","csv::row#values_at()","csv::table#values_at()","csv#write_headers?()","","","","","","",""],"info":[["Array","","Array.html","",""],["CSV","","CSV.html","","<p>CSV\n<p>CSV Data\n<p>CSV (comma-separated values) data is a text representation of a table:\n"],["CSV::FieldsConverter","","CSV/FieldsConverter.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["CSV::InputRecordSeparator","","CSV/InputRecordSeparator.html","",""],["CSV::InvalidEncodingError","","CSV/InvalidEncodingError.html","","<p>The error thrown when the parser encounters invalid encoding in CSV.\n"],["CSV::MalformedCSVError","","CSV/MalformedCSVError.html","","<p>The error thrown when the parser encounters illegal CSV formatting.\n"],["CSV::Parser","","CSV/Parser.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["CSV::Parser::InputsScanner","","CSV/Parser/InputsScanner.html","","<p>CSV::InputsScanner receives IO inputs, encoding and the chunk_size. It also controls the life cycle of …\n"],["CSV::Parser::InvalidEncoding","","CSV/Parser/InvalidEncoding.html","","<p>Raised when encoding is invalid.\n"],["CSV::Parser::Scanner","","CSV/Parser/Scanner.html","","<p>CSV::Scanner receives a CSV output, scans it and return the content. It also controls the life cycle …\n"],["CSV::Parser::UnexpectedError","","CSV/Parser/UnexpectedError.html","","<p>Raised when unexpected case is happen.\n"],["CSV::Row","","CSV/Row.html","","<p>CSV::Row\n<p>A CSV::Row instance represents a CSV table row. (see class CSV).\n<p>The instance may have:\n"],["CSV::TSV","","CSV/TSV.html","",""],["CSV::Table","","CSV/Table.html","","<p>CSV::Table\n<p>A CSV::Table instance represents CSV data. (see class CSV).\n<p>The instance may have:\n"],["CSV::Writer","","CSV/Writer.html","","<p>Note: Don’t use this class directly. This is an internal class.\n"],["Object","","Object.html","",""],["String","","String.html","",""],["<<","CSV","CSV.html#method-i-3C-3C","(row)","<p>Appends a row to <code>self</code>.\n<p>Argument <code>row</code> must be an Array object or a CSV::Row object.\n<p>The output stream must …\n"],["<<","CSV::Row","CSV/Row.html#method-i-3C-3C","(arg)","<p>Adds a field to <code>self</code>; returns <code>self</code>:\n<p>If the argument is a 2-element Array <code>[header, value]</code>, a field is added …\n"],["<<","CSV::Table","CSV/Table.html#method-i-3C-3C","(row_or_array)","<p>If <code>row_or_array</code> is a CSV::Row object, it is appended to the table:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["<<","CSV::Writer","CSV/Writer.html#method-i-3C-3C","(row)","<p>Adds a new row\n"],["==","CSV::Row","CSV/Row.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if <code>other</code> is a /CSV::Row that has the same fields (headers and values) in the same order …\n"],["==","CSV::Table","CSV/Table.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if all each row of <code>self</code> <code>==</code> the corresponding row of <code>other_table</code>, otherwise, <code>false</code>.\n<p>The access …\n"],["CSV","Object","Object.html#method-i-CSV","(*args, **options, &block)","<p>Passes <code>args</code> to CSV::instance.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>(<span class=\"ruby-string\">&quot;CSV,data&quot;</span>).<span class=\"ruby-identifier\">read</span>\n  <span class=\"ruby-comment\">#=&gt; [[&quot;CSV&quot;, &quot;data&quot;]]</span>\n</pre>\n<p>If a block is given, the instance …\n"],["[]","CSV::Row","CSV/Row.html#method-i-5B-5D","(header_or_index, minimum_index = 0)",""],["[]","CSV::Table","CSV/Table.html#method-i-5B-5D","(index_or_header)","<p>Returns data from the table;  does not modify the table.\n<p>Fetch a Row by Its Integer Index &mdash; \n<p>Form: <code>table[n]</code> …\n"],["[]=","CSV::Row","CSV/Row.html#method-i-5B-5D-3D","(*args)","<p>Assigns the field value for the given <code>index</code> or <code>header</code>; returns <code>value</code>.\n<p>Assign field value by Integer index: …\n"],["[]=","CSV::Table","CSV/Table.html#method-i-5B-5D-3D","(index_or_header, value)","<p>Puts data onto the table.\n<p>Set a Row by Its Integer Index &mdash; \n<p>Form: <code>table[n] = row</code>, <code>n</code> an Integer, <code>row</code> a CSV::Row …\n"],["add_converter","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-add_converter","(name=nil, &converter)",""],["add_row","CSV","CSV.html#method-i-add_row","(row)",""],["binmode?","CSV","CSV.html#method-i-binmode-3F","()",""],["by_col","CSV::Table","CSV/Table.html#method-i-by_col","()","<p>Returns a duplicate of <code>self</code>, in column mode (see Column Mode):\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["by_col!","CSV::Table","CSV/Table.html#method-i-by_col-21","()","<p>Sets the mode for <code>self</code> to column mode (see Column Mode); returns <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["by_col_or_row","CSV::Table","CSV/Table.html#method-i-by_col_or_row","()","<p>Returns a duplicate of <code>self</code>, in mixed mode (see Mixed Mode):\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["by_col_or_row!","CSV::Table","CSV/Table.html#method-i-by_col_or_row-21","()","<p>Sets the mode for <code>self</code> to mixed mode (see Mixed Mode); returns <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["by_row","CSV::Table","CSV/Table.html#method-i-by_row","()","<p>Returns a duplicate of <code>self</code>, in row mode (see Row Mode):\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["by_row!","CSV::Table","CSV/Table.html#method-i-by_row-21","()","<p>Sets the mode for <code>self</code> to row mode (see Row Mode); returns <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["check","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-check","(pattern)",""],["col_sep","CSV","CSV.html#method-i-col_sep","()","<p>Returns the encoded column separator; used for parsing and writing; see {Option <code>col_sep</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">col_sep</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["column_separator","CSV::Parser","CSV/Parser.html#method-i-column_separator","()",""],["convert","CSV","CSV.html#method-i-convert","(name = nil, &converter)","<p>With no block, installs a field converter (a Proc).\n<p>With a block, defines and installs a custom field …\n"],["convert","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-convert","(fields, headers, lineno, quoted_fields=NO_QUOTED_FIELDS)",""],["converters","CSV","CSV.html#method-i-converters","()","<p>Returns an Array containing field converters; see Field Converters:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">csv</span> = <span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>)\n<span class=\"ruby-identifier\">csv</span>.<span class=\"ruby-identifier\">converters</span> <span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["deconstruct","CSV::Row","CSV/Row.html#method-i-deconstruct","()","<p>Returns the new Array suitable for pattern matching containing the values of the row.\n"],["deconstruct_keys","CSV::Row","CSV/Row.html#method-i-deconstruct_keys","(keys)","<p>Returns the new Hash suitable for pattern matching containing only the keys specified as an argument. …\n"],["delete","CSV::Row","CSV/Row.html#method-i-delete","(header_or_index, minimum_index = 0)","<p>Removes a specified field from <code>self</code>; returns the 2-element Array <code>[header, value]</code> if the field exists. …\n"],["delete","CSV::Table","CSV/Table.html#method-i-delete","(*indexes_or_headers)","<p>If the access mode is <code>:row</code> or <code>:col_or_row</code>, and each argument is either an Integer or a Range, returns …\n"],["delete_if","CSV::Row","CSV/Row.html#method-i-delete_if","(&block)","<p>Removes fields from <code>self</code> as selected by the block; returns <code>self</code>.\n<p>Removes each field for which the block …\n"],["delete_if","CSV::Table","CSV/Table.html#method-i-delete_if","(&block)","<p>Removes rows or columns for which the block returns a truthy value; returns <code>self</code>.\n<p>Removes rows when the …\n"],["dig","CSV::Row","CSV/Row.html#method-i-dig","(index_or_header, *indexes)","<p>Finds and returns the object in nested object that is specified by <code>index_or_header</code> and <code>specifiers</code>.\n<p>The …\n"],["dig","CSV::Table","CSV/Table.html#method-i-dig","(index_or_header, *index_or_headers)","<p>Extracts the nested value specified by the sequence of <code>index</code> or <code>header</code> objects by calling dig at each …\n"],["each","CSV","CSV.html#method-i-each","(&block)","<p>Calls the block with each successive row. The data source must be opened for reading.\n<p>Without headers: …\n"],["each","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-each","(&block)",""],["each","CSV::Row","CSV/Row.html#method-i-each","(&block)","<p>Calls the block with each header-value pair; returns <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Name,Name\\nFoo,Bar,Baz\\n&quot;</span>\n<span class=\"ruby-identifier\">table</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each","CSV::Table","CSV/Table.html#method-i-each","(&block)","<p>Calls the block with each row or column; returns <code>self</code>.\n<p>When the access mode is <code>:row</code> or <code>:col_or_row</code>, calls …\n"],["each_line","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-each_line","(row_separator)",""],["each_line","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-each_line","(row_separator)",""],["each_pair","CSV::Row","CSV/Row.html#method-i-each_pair","(&block)",""],["empty?","CSV::FieldsConverter","CSV/FieldsConverter.html#method-i-empty-3F","()",""],["eof","CSV","CSV.html#method-i-eof","()",""],["eof?","CSV","CSV.html#method-i-eof-3F","()",""],["eof?","CSV::Parser","CSV/Parser.html#method-c-eof-3F","(input)","<p>Convenient method to check whether the give input reached EOF or not.\n"],["eos?","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-eos-3F","()",""],["fetch","CSV::Row","CSV/Row.html#method-i-fetch","(header, *varargs)","<p>Returns the field value as specified by <code>header</code>.\n<p>With the single argument <code>header</code>, returns the field value …\n"],["field","CSV::Row","CSV/Row.html#method-i-field","(header_or_index, minimum_index = 0)","<p>Returns the field value for the given <code>index</code> or <code>header</code>.\n<p>Fetch field value by Integer index:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["field?","CSV::Row","CSV/Row.html#method-i-field-3F","(data)","<p>Returns <code>true</code> if <code>value</code> is a field in this row, <code>false</code> otherwise:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Name,Name\\nFoo,Bar,Baz\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["field_row?","CSV::Row","CSV/Row.html#method-i-field_row-3F","()","<p>Returns <code>true</code> if this is a field row, <code>false</code> otherwise.\n"],["field_size_limit","CSV","CSV.html#method-i-field_size_limit","()","<p>Returns the limit for field size; used for parsing; see {Option <code>field_size_limit</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">field_size_limit</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["field_size_limit","CSV::Parser","CSV/Parser.html#method-i-field_size_limit","()",""],["fields","CSV::Row","CSV/Row.html#method-i-fields","(*headers_and_or_indices)","<p>Returns field values per the given <code>specifiers</code>, which may be any mixture of:\n<p>Integer index.\n<p>Range of Integer …\n"],["filter","CSV","CSV.html#method-c-filter","(input=nil, output=nil, **options)","<p>Parses CSV from a source (String, IO stream, or ARGF).\n<p>Calls the given block with each parsed row:\n<p>Without …\n"],["flock","CSV","CSV.html#method-i-flock","(*args)",""],["force_quotes?","CSV","CSV.html#method-i-force_quotes-3F","()","<p>Returns the value that determines whether all output fields are to be quoted; used for generating; see …\n"],["foreach","CSV","CSV.html#method-c-foreach","(path, mode=\"r\", **options, &block)","<p>Calls the block with each row read from source <code>path_or_io</code>.\n<p>Path input without headers:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">string</span> = <span class=\"ruby-string\">&quot;foo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["generate","CSV","CSV.html#method-c-generate","(str=nil, **options)","<p>Argument <code>csv_string</code>, if given, must be a String object; defaults to a new empty String.\n<p>Arguments <code>options</code> …\n\n"],["generate_line","CSV","CSV.html#method-c-generate_line","(row, **options)","<p>Returns the String created by generating CSV from <code>ary</code> using the specified <code>options</code>.\n<p>Argument <code>ary</code> must be …\n"],["generate_lines","CSV","CSV.html#method-c-generate_lines","(rows, **options)","<p>Returns the String created by generating CSV from using the specified <code>options</code>.\n<p>Argument <code>rows</code> must be an …\n"],["gets","CSV","CSV.html#method-i-gets","()",""],["has_key?","CSV::Row","CSV/Row.html#method-i-has_key-3F","(header)","<p>Returns <code>true</code> if there is a field with the given <code>header</code>, <code>false</code> otherwise.\n"],["header?","CSV::Row","CSV/Row.html#method-i-header-3F","(header)",""],["header_convert","CSV","CSV.html#method-i-header_convert","(name = nil, &converter)","<p>The block need not return a String object:\n\n<pre>csv = CSV.open(path, headers: true)\ncsv.header_convert {|header, ...</pre>\n"],["header_converters","CSV","CSV.html#method-i-header_converters","()","<p>Returns an Array containing header converters; used for parsing; see Header Converters:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">header_converters</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["header_row?","CSV","CSV.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if the next row to be read is a header row; <code>false</code> otherwise.\n<p>Without headers:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">string</span> = <span class=\"ruby-string\">&quot;foo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["header_row?","CSV::Parser","CSV/Parser.html#method-i-header_row-3F","()",""],["header_row?","CSV::Row","CSV/Row.html#method-i-header_row-3F","()","<p>Returns <code>true</code> if this is a header row, <code>false</code> otherwise.\n"],["headers","CSV","CSV.html#method-i-headers","()","<p>Returns the value that determines whether headers are used; used for parsing; see {Option <code>headers</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">headers</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["headers","CSV::Parser","CSV/Parser.html#method-i-headers","()",""],["headers","CSV::Row","CSV/Row.html#method-i-headers","()","<p>Returns the headers for this row:\n\n<pre>source = &quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;\ntable = CSV.parse(source, ...</pre>\n"],["headers","CSV::Table","CSV/Table.html#method-i-headers","()","<p>Returns a new Array containing the String headers for the table.\n<p>If the table is not empty, returns the …\n"],["include?","CSV::Row","CSV/Row.html#method-i-include-3F","(header)",""],["index","CSV::Row","CSV/Row.html#method-i-index","(header, minimum_index = 0)","<p>Returns the index for the given header, if it exists; otherwise returns <code>nil</code>.\n<p>With the single argument …\n"],["initialize_copy","CSV::Row","CSV/Row.html#method-i-initialize_copy","(other)","<p>Calls superclass method.\n"],["inspect","CSV","CSV.html#method-i-inspect","()","<p>Returns a String showing certain properties of <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">string</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span>\n<span class=\"ruby-identifier\">csv</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["inspect","CSV::Row","CSV/Row.html#method-i-inspect","()","<p>Returns an ASCII-compatible String showing:\n<p>Class CSV::Row.\n<p>Header-value pairs.\n"],["inspect","CSV::Table","CSV/Table.html#method-i-inspect","()","<p>Returns a <code>US-ASCII</code>-encoded String showing table:\n<p>Class: <code>CSV::Table</code>.\n<p>Access mode: <code>:row</code>, <code>:col</code>, or <code>:col_or_row</code> …\n"],["instance","CSV","CSV.html#method-c-instance","(data = $stdout, **options)","<p>Creates or retrieves cached CSV objects. For arguments and options, see CSV.new.\n<p>This API is not Ractor-safe. …\n"],["ioctl","CSV","CSV.html#method-i-ioctl","(*args)",""],["keep_back","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_back","()",""],["keep_back","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_back","()",""],["keep_drop","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_drop","()",""],["keep_drop","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_drop","()",""],["keep_end","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_end","()",""],["keep_end","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_end","()",""],["keep_start","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-keep_start","()",""],["keep_start","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-i-keep_start","()",""],["key?","CSV::Row","CSV/Row.html#method-i-key-3F","(header)",""],["liberal_parsing?","CSV","CSV.html#method-i-liberal_parsing-3F","()","<p>Returns the value that determines whether illegal input is to be handled; used for parsing; see {Option …\n"],["liberal_parsing?","CSV::Parser","CSV/Parser.html#method-i-liberal_parsing-3F","()",""],["line","CSV","CSV.html#method-i-line","()","<p>Returns the line most recently read:\n\n<pre>string = &quot;foo,0\\nbar,1\\nbaz,2\\n&quot;\npath = &#39;t.csv&#39;\nFile.write(path, ...</pre>\n"],["line","CSV::Parser","CSV/Parser.html#method-i-line","()",""],["lineno","CSV","CSV.html#method-i-lineno","()","<p>Returns the count of the rows parsed or generated.\n<p>Parsing:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">string</span> = <span class=\"ruby-string\">&quot;foo,0\\nbar,1\\nbaz,2\\n&quot;</span>\n<span class=\"ruby-identifier\">path</span> = <span class=\"ruby-string\">&#39;t.csv&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["lineno","CSV::Parser","CSV/Parser.html#method-i-lineno","()",""],["max_field_size","CSV","CSV.html#method-i-max_field_size","()","<p>Returns the limit for field size; used for parsing; see {Option <code>max_field_size</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">max_field_size</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["max_field_size","CSV::Parser","CSV/Parser.html#method-i-max_field_size","()",""],["member?","CSV::Row","CSV/Row.html#method-i-member-3F","(header)",""],["new","CSV","CSV.html#method-c-new","(data, col_sep: \",\", row_sep: :auto, quote_char: '\"', field_size_limit: nil, max_field_size: nil, converters: nil, unconverted_fields: nil, headers: false, return_headers: false, write_headers: nil, header_converters: nil, skip_blanks: false, force_quotes: false, skip_lines: nil, liberal_parsing: false, internal_encoding: nil, external_encoding: nil, encoding: nil, nil_value: nil, empty_value: \"\", strip: false, quote_empty: true, write_converters: nil, write_nil_value: nil, write_empty_value: \"\")","<p>Returns the new CSV object created using <code>string</code> or <code>io</code> and the specified <code>options</code>.\n<p>Argument <code>string</code> should …\n"],["new","CSV::FieldsConverter","CSV/FieldsConverter.html#method-c-new","(options={})","<p>A CSV::FieldsConverter is a data structure for storing the fields converter properties to be passed as …\n"],["new","CSV::InvalidEncodingError","CSV/InvalidEncodingError.html#method-c-new","(encoding, line_number)",""],["new","CSV::MalformedCSVError","CSV/MalformedCSVError.html#method-c-new","(message, line_number)",""],["new","CSV::Parser","CSV/Parser.html#method-c-new","(input, options)",""],["new","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-c-new","(inputs, encoding, row_separator, chunk_size: 8192)",""],["new","CSV::Parser::Scanner","CSV/Parser/Scanner.html#method-c-new","(*args)",""],["new","CSV::Row","CSV/Row.html#method-c-new","(headers, fields, header_row = false)","<p>Returns the new CSV::Row instance constructed from arguments <code>headers</code> and <code>fields</code>; both should be Arrays …\n"],["new","CSV::TSV","CSV/TSV.html#method-c-new","(data, **options)",""],["new","CSV::Table","CSV/Table.html#method-c-new","(array_of_rows, headers: nil)","<p>Returns a new CSV::Table object.\n<p>Argument <code>array_of_rows</code> must be an Array of CSV::Row objects.\n<p>Argument …\n"],["new","CSV::Writer","CSV/Writer.html#method-c-new","(output, options)",""],["open","CSV","CSV.html#method-c-open","(filename_or_io, mode=\"r\", **options)","<p>possible options elements:\n\n<pre>keyword form:\n  :invalid =&gt; nil      # raise error on invalid byte sequence ...</pre>\n"],["parse","CSV","CSV.html#method-c-parse","(str, **options, &block)","<p>Parses <code>string</code> or <code>io</code> using the specified <code>options</code>.\n<p>Argument <code>string</code> should be a String object; it will be …\n"],["parse","CSV::Parser","CSV/Parser.html#method-i-parse","(&block)",""],["parse_csv","String","String.html#method-i-parse_csv","(**options)","<p>Equivalent to CSV::parse_line(self, options)\n\n<pre class=\"ruby\"><span class=\"ruby-string\">&quot;CSV,data&quot;</span>.<span class=\"ruby-identifier\">parse_csv</span>\n  <span class=\"ruby-comment\">#=&gt; [&quot;CSV&quot;, &quot;data&quot;]</span>\n</pre>\n"],["parse_line","CSV","CSV.html#method-c-parse_line","(line, **options)","<p>Returns the data created by parsing the first line of <code>string</code> or <code>io</code> using the specified <code>options</code>.\n<p>Argument …\n"],["path","CSV","CSV.html#method-i-path","()",""],["push","CSV::Row","CSV/Row.html#method-i-push","(*args)","<p>Appends each of the given <code>values</code> to <code>self</code> as a field; returns <code>self</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Name,Name\\nFoo,Bar,Baz\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["push","CSV::Table","CSV/Table.html#method-i-push","(*rows)","<p>A shortcut for appending multiple rows. Equivalent to:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">rows</span>.<span class=\"ruby-identifier\">each</span> {<span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">row</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-keyword\">self</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\">row</span> }\n</pre>\n<p>Each argument may …\n"],["puts","CSV","CSV.html#method-i-puts","(row)",""],["quote_char","CSV","CSV.html#method-i-quote_char","()","<p>Returns the encoded quote character; used for parsing and writing; see {Option <code>quote_char</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">quote_char</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["quote_character","CSV::Parser","CSV/Parser.html#method-i-quote_character","()",""],["read","CSV","CSV.html#method-c-read","(path, **options)","<p>Opens the given <code>source</code> with the given <code>options</code> (see CSV.open), reads the source (see CSV#read), and returns …\n"],["read","CSV","CSV.html#method-i-read","()","<p>Forms the remaining rows from <code>self</code> into:\n<p>A CSV::Table object, if headers are in use.\n<p>An Array of Arrays …\n"],["readline","CSV","CSV.html#method-i-readline","()",""],["readlines","CSV","CSV.html#method-c-readlines","(path, **options)","<p>Alias for CSV.read.\n"],["readlines","CSV","CSV.html#method-i-readlines","()",""],["rest","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-rest","()",""],["return_headers?","CSV","CSV.html#method-i-return_headers-3F","()","<p>Returns the value that determines whether headers are to be returned; used for parsing; see {Option  …\n"],["return_headers?","CSV::Parser","CSV/Parser.html#method-i-return_headers-3F","()",""],["rewind","CSV","CSV.html#method-i-rewind","()","<p>Rewinds the underlying IO object and resets CSV’s lineno() counter.\n"],["rewind","CSV::Writer","CSV/Writer.html#method-i-rewind","()","<p>Winds back to the beginning\n"],["row_sep","CSV","CSV.html#method-i-row_sep","()","<p>Returns the encoded row separator; used for parsing and writing; see {Option <code>row_sep</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">row_sep</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["row_separator","CSV::Parser","CSV/Parser.html#method-i-row_separator","()",""],["scan","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan","(pattern)",""],["scan_all","CSV::Parser::InputsScanner","CSV/Parser/InputsScanner.html#method-i-scan_all","(pattern)",""],["shift","CSV","CSV.html#method-i-shift","()","<p>Returns the next row of data as:\n<p>An Array if no headers are used.\n<p>A CSV::Row object if headers are used. …\n"],["skip_blanks?","CSV","CSV.html#method-i-skip_blanks-3F","()","<p>Returns the value that determines whether blank lines are to be ignored; used for parsing; see {Option …\n"],["skip_blanks?","CSV::Parser","CSV/Parser.html#method-i-skip_blanks-3F","()",""],["skip_lines","CSV","CSV.html#method-i-skip_lines","()","<p>Returns the Regexp used to identify comment lines; used for parsing; see {Option <code>skip_lines</code>}:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">CSV</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;&#39;</span>).<span class=\"ruby-identifier\">skip_lines</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["skip_lines","CSV::Parser","CSV/Parser.html#method-i-skip_lines","()",""],["stat","CSV","CSV.html#method-i-stat","(*args)",""],["table","CSV","CSV.html#method-c-table","(path, **options)","<p>Calls CSV.read with <code>source</code>, <code>options</code>, and certain default options:\n<p><code>headers</code>: <code>true</code>\n<p><code>converters</code>: <code>:numeric</code>\n"],["to_a","CSV::Table","CSV/Table.html#method-i-to_a","()","<p>Returns the table as an Array of Arrays; the headers are in the first row:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_csv","Array","Array.html#method-i-to_csv","(**options)","<p>Equivalent to CSV::generate_line(self, options)\n\n<pre class=\"ruby\">[<span class=\"ruby-string\">&quot;CSV&quot;</span>, <span class=\"ruby-string\">&quot;data&quot;</span>].<span class=\"ruby-identifier\">to_csv</span>\n  <span class=\"ruby-comment\">#=&gt; &quot;CSV,data\\n&quot;</span>\n</pre>\n"],["to_csv","CSV::Row","CSV/Row.html#method-i-to_csv","(**options)","<p>Returns the row as a CSV String. Headers are not included:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> = <span class=\"ruby-string\">&quot;Name,Value\\nfoo,0\\nbar,1\\nbaz,2\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_csv","CSV::Table","CSV/Table.html#method-i-to_csv","(write_headers: true, limit: nil, **options)","<p>Returns the table as CSV string. See Options for Generating.\n<p>Defaults option <code>write_headers</code> to <code>true</code>:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">source</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_h","CSV::Row","CSV/Row.html#method-i-to_h","()","<p>Returns the new Hash formed by adding each header-value pair in <code>self</code> as a key-value pair in the Hash …\n"],["to_hash","CSV::Row","CSV/Row.html#method-i-to_hash","()",""],["to_i","CSV","CSV.html#method-i-to_i","()",""],["to_io","CSV","CSV.html#method-i-to_io","()",""],["to_s","CSV::Row","CSV/Row.html#method-i-to_s","(**options)",""],["to_s","CSV::Table","CSV/Table.html#method-i-to_s","(write_headers: true, limit: nil, **options)",""],["unconverted_fields?","CSV","CSV.html#method-i-unconverted_fields-3F","()","<p>Returns the value that determines whether unconverted fields are to be available; used for parsing; see …\n"],["unconverted_fields?","CSV::Parser","CSV/Parser.html#method-i-unconverted_fields-3F","()",""],["use_headers?","CSV::Parser","CSV/Parser.html#method-i-use_headers-3F","()",""],["value","CSV::InputRecordSeparator","CSV/InputRecordSeparator.html#method-c-value","()",""],["values_at","CSV::Row","CSV/Row.html#method-i-values_at","(*headers_and_or_indices)",""],["values_at","CSV::Table","CSV/Table.html#method-i-values_at","(*indices_or_headers)","<p>If the access mode is <code>:row</code> or <code>:col_or_row</code>, and each argument is either an Integer or a Range, returns …\n"],["write_headers?","CSV","CSV.html#method-i-write_headers-3F","()","<p>Returns the value that determines whether headers are to be written; used for generating; see {Option …\n"],["LICENSE","","LICENSE_txt.html","","<p>Copyright © 2005-2016 James Edward Gray II. All rights reserved. Copyright © 2007-2017 Yukihiro  …\n"],["NEWS","","NEWS_md.html","","<p>News\n<p>3.3.4 - 2025-04-13\n<p>Improvements\n"],["README","","README_md.html","","<p>CSV\n<p>This library provides a complete interface to CSV files and data. It offers tools to enable you to …\n"],["filtering","","doc/csv/recipes/filtering_rdoc.html","","<p>Recipes for Filtering CSV\n<p>These recipes are specific code examples for specific CSV filtering tasks.\n<p>For …\n"],["generating","","doc/csv/recipes/generating_rdoc.html","","<p>Recipes for Generating CSV\n<p>These recipes are specific code examples for specific CSV generating tasks. …\n"],["parsing","","doc/csv/recipes/parsing_rdoc.html","","<p>Recipes for Parsing CSV\n<p>These recipes are specific code examples for specific CSV parsing tasks.\n<p>For other …\n"],["recipes","","doc/csv/recipes/recipes_rdoc.html","","<p>Recipes for CSV\n<p>The recipes are specific code examples for specific tasks. See:\n<p>Recipes for Parsing CSV …\n"]]}}